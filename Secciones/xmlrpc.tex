\section{XML-RPC}

XML-RPC es uno de los protocolos de Servicios Web que citamos en el primer capítulo, y que se puede decir, 
de los más importantes, ya que Drupal lo soporta de manera nativa. Es decir, este protocolo está implementado 
en el Drupal sin necesitar módulos o librerías de la comunidad. En este capítulo, aprenderemos a trabajar con él 
y utilizarlo como un cliente y como un proveedor de Servicios Web.

\subsection{¿Qué es XML-RPC?}

Al igual que el protocolo SOAP visto anteriormente, XML-RPC se basa en RPC (\textit{Remote Procedure Call}), es decir, 
en llamadas a procedimientos remotos, para enviar y recibir mensajes cifrados en XML a través del protocolo HTTP.
Dichos mensajes contienen información sobre:

\begin{itemize}
  \item El procedimiento que se va a ejecutar en el servidor.
  \item Los parámetros
\end{itemize} 

Además, el servidor devuelve el resultado en formato XML.

\subsubsection{Diferencias entre XML-RPC y SOAP}

XML-RPC fue el primer mecanismo que surgió para invocar procedimientos remotos vía XML, ofrece una manera 
muy sencilla de invocar operaciones en sistemas heterogéneos a través de una estructura simple. Sin embargo, 
SOAP es una implementación más robusta para llevar acabo una intercomunicación en XML, a diferencia de XML-RPC 
a SOAP se le han integrado diversos mecanismos que le permiten operar en ambientes distribuidos mas complejos tales 
como:

\begin{itemize}
  \item Un lenguaje neutro para su descripción (WSDL/``Web Services Description Language'').
  \item Directorios distribuidos para su ubicación (UDDI/``Universal Discovery, Description and Integration'')  
\end{itemize} 

\subsubsection{Prerrequisitos para XML-RPC}

Si lo que queremos implementar es un servidor de peticiones, no tenemos que preocuparnos de ningún requisito previo, ya 
que al ser mensajes enviados a través de HTTP, utilizarán el puerto web estándar (puerto 80). El fichero \verb|xmlrpc.php| 
del directorio raíz de nuestro Drupal recibirá las peticiones y las enrutará.

Para ser usado como cliente, solo tenemos que tener en cuenta que muchas empresas de alojamiento Web no nos permiten 
realizar peticiones HTTP por razones de seguridad. Sería conveniente contactar con nuestro proveedor si no estamos seguros 
si nuestros clientes funcionarán.

\subsection{Drupal como servidor XML-RPC}

Para configurar nuestro Drupal como un Servidor Web XML-RPC necesitaremos implementar tres puntos:

\begin{enumerate}
  \item Relación entre nombre de método remoto y función PHP a ejecutarse al ser llamados.
  \item La firma del método (\textit{signature}): tipo de retorno y de parámetros requeridos. Un método puede tener varias firmas.
  \item Documentación del método (\textit{docstring}).
\end{enumerate}

Como es normal en Drupal, vamos a implementar el ejemplo como un pequeño módulo que responda a peticiones. Procedemos pues a 
crear un ``Hola Mundo'' de un Servidor XML-RPC en Drupal, con la estructura y el código básicos. Para empezar, generaremos el 
fichero de información del módulo en \verb|sites/all/modules/holaxmlrpc/holaxmlrpc.info|:

\begin{verbatim}
name = Hola Mundo - Servidor XML RPC
description = Módulo que responderá con un "Hola" a cada petición XML-RPC 
				que se le realice a nuestro Drupal
package = Libro Experto Drupal 7
core = 7.x 
\end{verbatim}

El código de \verb|holaxmlrpc.module| quedaría como sigue:

\begin{verbatim}
<?php

/**
 * Implementacion del metodo hook_xmlrpc()
 * Relaciona nombre de procedimiento remoto y función PHP a ejecutarse
 */

function holaxmlrpc_xmlrpc()
{
    $metodos['remotoHola.hola'] = 'xmls_holaxmlrpc_hola';
    return $methodos;
}

/**
 * Saluda a una peticion
 * @param string $nombre
 */
function xmls_holaxmlrpc_hola($nombre) {
    if(!$nombre){
        return xmlrpc_error(1, t("Perdona, no te puedo saludar si no me dices tu nombre"));
    }
    return t("¡Hola, @nombre! ¿Que tal?", array("@nombre" => $nombre));
}
\end{verbatim}

¡Así de simple! Podemos complicar más nuestro servidor añadiendo más métodos en el array servicios de nuestro 
Drupal y validando los parámetros de entrada de las peticiones que se nos realizan. Primero veamos cómo funciona 
el \verb|hook\_xmlrpc()| y como testear este servicio.

Este \textit{hook} permite a un módulo registrar mapeos entre métodos de un Servicio Web y funciones de PHP 
a ejecutar, cuando un cliente invoca a los métodos de nuestro servidor XML-RPC. Devuelve un array con el mapeo así 
como configuración referida a la firma del método y la documentación del mismo. En nuestro ejemplo, el método 
\verb|remotoHola.hola| será el método público, y gracias a \verb|hook_xmlrpc()|, cada llamada a este método se 
manejará a través de la función PHP \verb|xmls_holaxmlrpc_hola()|. Normalmente se utiliza el prefijo \verb|xmls_|\footnote{
\textit{xmlns} es el atributo que se utiliza en XML para designar el espacio de nombres o \textit{namespace}} para las funciones 
PHP para indicar que esta función habla con el mundo exterior.

Además, podemos observar que en el código hemos útilizado un método para designar un error en la petición: 
\verb|xmlrpc_error()|, mediante el cual podemos indicar el código de error y el mensaje que se enviará al cliente. Los 
códigos de error son específicos de nuestra implementación, así que podremos utilizarlos a nuestro gusto.

Probemos nuestro servicio. Asumiendo que el módulo está alojado en un servidor \verb|ejemplo.com| y que nos 
encontramos en \verb|localhost|, tendremos que hacer una petición como la que sigue para comprobarlo:

\begin{verbatim}
$url = 'http://ejemplo.com/xmlrpc.php';
$nombre_metodo = 'remotoHola.hola';
$nombre = t('Fran');
$resultado = xmlrpc($url, array($nombre_metodo => array($nombre)));
\end{verbatim}

El resultado de ejecutar el código es:

\begin{verbatim}
echo $resultado;
>> "¡Hola, Fran! ¿Que tal?"
\end{verbatim}

\subsubsection{Firma y validación de los métodos} 

Podemos, como mencionamos, validar los parámetros de entrada automáticamente utilizando el \verb|hook_xmlrpc()|. 
De esta manera, comprobaremos a nivel de servidor el mensaje que intentan enviarnos en la petición es correcto, sin 
añadir más lógica a nuestra función PHP final. Es muy recomendable utilizar esta validación, ya que Drupal 
se encargará de responder a las peticiones con respeto a nuestra firma de método, y si el mensaje no satisface 
lo descrito, será un método de Drupal (\verb|xmlrpc_server_call()|) el que responda con uno de los siguientes 
mensajes de error:
\begin{verbatim}
-32602: Server error. Invalid method parameters.
-32602: Server error. Wrong number of method parameters.
\end{verbatim}
dependiendo del caso.

La lista de todas las posibles validaciones de entrada se puede 
consultar en \verb|http://xmlrpc.scripting.com/spec.html|.

Veamos un ejemplo de cómo añadir la firma y validación a nuestro método:

\begin{verbatim}
/**
 * Implementacion del metodo hook_xmlrpc()
 * Relaciona nombre de procedimiento remoto y función PHP a ejecutarse
 */
function holaxmlrpc_xmlrpc() {
    $metodos = array();
    $metodos[] = array(
        'remotoHola.hola',         // Nombe de nuestro metodo externo
        'xmls_holaxmlrpc_hola',    // Funcion PHP a ejecutar
        array('string', 'String'), // Parametro de salida y despues, 
                                   // todos los tipos de parametros de entrada
        t('Saluda a clientes XML-RPC') // Descripcion
    );
    return $metodos;
}
\end{verbatim}

El siguiente diagrama nos servirá para mostarnos el ciclo de vida de una petición XML-RPC y para introducir términos 
relacionados con los métodos de sistema en XML-RPC:

\begin{figure}[h]
  \centering
    \includegraphics[width=1\textwidth]{Assets/xmlrpc/Imagenes/workflow.png}
  \caption{Diagrama de flujo de una petición XML-RPC}
\end{figure}

\newpage
\subsubsection{Métodos XML-RPC de Drupal}

Drupal tiene un listado de métodos de sistema para trabajar con XML-RPC como servidor. En este apartado describiremos 
cada uno de ellos.

\large{system.listMethods} 	

Se utiliza para listar todos los métodos disponibles de un Servidor XML-RPC. El método recorrerá todos los \verb|hook_xmlrpc()| 
de los módulos activos para obtener un array de dichos métodos.  Para realizar una petición, haremos algo como:

\begin{verbatim}
// Array con todos los métodos XML-RPC disponibles en el servidor
$url = 'http://ejemplo.com/xmlrpc.php';
$metodos = xmlrpc($url, array('system.listMethods'));
\end{verbatim}

La respuesta será un mensaje como el siguiente:

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<methodResponse>
    <params>
        <param>
            <value>
                <array>
                    <data>
                        <value>
                            <string>system.multicall</string>
                        </value>
                        <value>
                            <string>system.methodSignature</string>
                        </value>
                        <value>
                            <string>system.getCapabilities</string>
                        </value>
                        <value>
                            <string>system.listMethods</string>
                        </value>
                        <value>
                            <string>system.methodHelp</string>
                        </value>
                        <value>
                            <string>remotoHola.hola</string>
                        </value>
                    </data>
                </array>
            </value>
        </param>
    </params>
</methodResponse>
\end{verbatim}

Así pues, ahora \verb|$metodos| contendrá un array con todos los métodos disponibles del sistema:

\begin{verbatim}
var_dump($metodos);
>> array('system.multicall', 'system.methodSignature',
		'system.getCapabilities', 'system.listMethods', 
		'system.methodHelp', 'remotoHola.hola')
\end{verbatim}

\large{system.methodSignature} 	
